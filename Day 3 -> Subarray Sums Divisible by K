Question Link : https://leetcode.com/problems/subarray-sums-divisible-by-k/description/


Code :


//Basic Recursion Code (Giving TLE)

// class Solution {
// public:
//     void findAns(int idx, int sum, int& ans, int n, int k, vector<int>& nums) {
//         if (idx >= n) {
//             return;
//         }
        
//         // Update sum with the current element
//         sum += nums[idx];
        
//         // Check if the current subarray sum is divisible by k
//         if (sum % k == 0) {
//             ans++;
//         }
        
//         // Move to the next index
//         findAns(idx + 1, sum, ans, n, k, nums);
//     }
    
//     int subarraysDivByK(vector<int>& nums, int k) {
//         int n = nums.size();
//         int ans = 0;
        
//         // Start the recursion for each possible starting index
//         for (int i = 0; i < n; i++) {
//             findAns(i, 0, ans, n, k, nums);
//         }
        
//         return ans;
//     }
// };




#pragma GCC optimize("03", "unroll-loops")
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size();
        if(n==0){
            return 0;
        }
        int i = 0, curr_sum = 0, ans = 0;
        unordered_map<int, int>mp;
        mp[0] = 1;
        while(i<n){
            curr_sum+=nums[i];
            int rem = curr_sum%k;
            if(rem<0) rem+=k;

            if(mp.find(rem)!=mp.end()){
                ans+=mp[rem];
            }
            mp[rem]++;
            i++;
        }
        return ans;
    }
};
auto init = [](){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 'c';
}();
