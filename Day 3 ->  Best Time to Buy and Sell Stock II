Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/


Code :


//GREEDY

// #pragma GCC optimize("03", "unroll-loops")
// class Solution {
// public:
//     int maxProfit(vector<int>& prices) {
//         int ans = 0;
//         int n = prices.size();
//         for(int i=1;i<n;i++){
//             if(prices[i]>prices[i-1]){
//                 ans+=(prices[i]-prices[i-1]);
//             }
//         }
//         return ans;
//     }
// };
// auto init = [](){
//     ios::sync_with_stdio(false);
//     cin.tie(nullptr);
//     cout.tie(nullptr);
//     return 'c';
// }();



// //Recursion

// #pragma GCC optimize("03", "unroll-loops")
// class Solution {
// public:
//     int findAns(int idx, int n, int buy, int&profit, vector<int>&prices){
//         if(idx==n){
//             return 0;
//         }
//         if(buy==1){
//             profit = max(-prices[idx]+findAns(idx+1, n, 0, profit, prices), findAns(idx+1, n, 1, profit, prices));
//         }
//         else{
//             profit = max(prices[idx]+findAns(idx+1, n, 1, profit, prices), findAns(idx+1, n, 0, profit, prices));
//         }
//         return profit;
//     }
//     int maxProfit(vector<int>& prices) {
//         //1 means can buy and 0 means can't buy
//         int profit = 0;
//         int n = prices.size();
//         return findAns(0, n, 1, profit, prices);
//     }
// };
// auto init = [](){
//     ios::sync_with_stdio(false);
//     cin.tie(nullptr);
//     cout.tie(nullptr);
//     return 'c';
// }();




//MEMOIZATION

// #pragma GCC optimize("03", "unroll-loops")
// class Solution {
// public:
//     int findAns(int idx, int n, int buy, int&profit, vector<int>&prices, vector<vector<int>>&dp){
//         if(idx==n){
//             return 0;
//         }
//         if(dp[idx][buy]!=-1){
//             return dp[idx][buy];
//         }
//         if(buy==1){
//             profit = max(-prices[idx]+findAns(idx+1, n, 0, profit, prices, dp), findAns(idx+1, n, 1, profit, prices, dp));
//         }
//         else{
//             profit = max(prices[idx]+findAns(idx+1, n, 1, profit, prices, dp), findAns(idx+1, n, 0, profit, prices, dp));
//         }
//         return dp[idx][buy] = profit;
//     }
//     int maxProfit(vector<int>& prices) {
//         //1 means can buy and 0 means can't buy
//         int profit = 0;
//         int n = prices.size();
//         vector<vector<int>>dp(n, vector<int>(2, -1));
//         return findAns(0, n, 1, profit, prices, dp);
//     }
// };
// auto init = [](){
//     ios::sync_with_stdio(false);
//     cin.tie(nullptr);
//     cout.tie(nullptr);
//     return 'c';
// }();




//TABULATION

#pragma GCC optimize("03", "unroll-loops")
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>>dp(n+1, vector<int>(2, 0));

        //base condition for tabulation
        dp[n][0] = dp[n][1] = 0;

        //traverse for tabulation
        for(int idx=n-1;idx>=0;idx--){
            for(int buy = 0; buy<=1;buy++){
                int profit = 0;
                if(buy){
                    profit = max(-prices[idx]+dp[idx+1][0], dp[idx+1][1]);
                }
                else{
                    profit = max(prices[idx]+dp[idx+1][1], dp[idx+1][0]);
                }
                dp[idx][buy] = profit;
            }
        }

        //return the answer
        return dp[0][1];
    }
};
auto init = [](){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 'c';
}();




//TABULATION + SPACE OPTIMIZATION


// #pragma GCC optimize("03", "unroll-loops")
// class Solution {
// public:
//     int maxProfit(vector<int>& prices) {
//         int n = prices.size();
//         //make 2 vectors
//         vector<int>ahead(2, 0);
//         vector<int>curr(2, 0);

//         //base condition for tabulation
//         ahead[0] = ahead[1] = 0;

//         //traverse for tabulation
//         for(int idx=n-1;idx>=0;idx--){
//             for(int buy = 0; buy<=1;buy++){
//                 int profit = 0;
//                 if(buy){
//                     profit = max(-prices[idx]+ahead[0], ahead[1]);
//                 }
//                 else{
//                     profit = max(prices[idx]+ahead[1], ahead[0]);
//                 }
//                 curr[buy] = profit;
//             }
//             ahead = curr;
//         }

//         //return the answer
//         return ahead[1];
//     }
// };
// auto init = [](){
//     ios::sync_with_stdio(false);
//     cin.tie(nullptr);
//     cout.tie(nullptr);
//     return 'c';
// }();





//TABULATION + SPACE OPTIMIZATION ( USING 4 VARIABLES )

// #pragma GCC optimize("03", "unroll-loops")
// class Solution {
// public:
//     int maxProfit(vector<int>& prices) {
//         int n = prices.size();
//         int aheadNotBuy = 0, aheadBuy = 0, currNotBuy = 0, currBuy = 0;

//         for(int idx=n-1;idx>=0;idx--){
//             currNotBuy = max(prices[idx]+aheadBuy, aheadNotBuy);
//             currBuy = max(-prices[idx]+aheadNotBuy, aheadBuy);

//             aheadNotBuy = currNotBuy;
//             aheadBuy = currBuy;
//         }

//         return aheadBuy;
//     }
// };
// auto init = [](){
//     ios::sync_with_stdio(false);
//     cin.tie(nullptr);
//     cout.tie(nullptr);
//     return 'c';
// }();




